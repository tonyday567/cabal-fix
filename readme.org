* cabal-fix

[[https://hackage.haskell.org/package/cabal-fixes][https://img.shields.io/hackage/v/cabal-fix.svg]]
[[https://github.com/tonyday567/cabal-fixes/actions?query=workflow%3Ahaskell-ci][https://github.com/tonyday567/cabal-fix/workflows/haskell-ci/badge.svg]]

~cabal-fix~ helps fix warts in your cabal files.

~cabal-fix~:

- Contains an app which parses your existing cabal file, re-renders it according to some config, then either displays a diff, or overwrites the filke. It will trash your prior formatting notions.
- Is an idempotent parser of a cabal file or ByteString.
- Is an inexact printer.
- Contains code to explore the cabal index archive at the base of your cabal installation.

* App Usage

#+begin_src sh :results output
cabal-fix --help
#+end_src

#+RESULTS:
#+begin_example
fixes your cabal file

Usage: cabal-fix [-i|--inplace] [-f|--configFile ARG] [-g|--gen]

  cabal fixer

Available options:
  -i,--inplace             fix the cabal file inplace
  -f,--configFile ARG      config file
  -g,--gen                 generate config file
  -h,--help                Show this help text
#+end_example

* App Configuration

The configuration of cabal-fix is encapsulated in the Config type. The configuration file generated by the app (via --gen) is the pretty printing of defaultConfig.

#+begin_src haskell-ng :results output
import Text.Pretty.Simple
pPrint defaultConfig
#+end_src

#+RESULTS:
#+begin_example
Config
    { freeTexts = [ "description" ]
    , removals = []
    , preferredDeps =
        [
            ( "base"
            , ">=4.7 && <5"
            )
        ]
    , overwrites = []
    , fixCommas =
        [
            ( "extra-doc-files"
            , NoCommas
            )
        ,
            ( "build-depends"
            , PrefixCommas
            )
        ]
    , sortFieldLines =
        [ "build-depends"
        , "exposed-modules"
        , "default-extensions"
        , "ghc-options"
        , "extra-doc-files"
        , "tested-with"
        ]
    , sortFields = True
    , fieldOrdering =
        [
            ( "cabal-version"
            , 0.0
            )
        ,
            ( "import"
            , 1.0
            )
        ,
            ( "main-is"
            , 2.0
            )
        ,
            ( "default-language"
            , 3.0
            )
        ,
            ( "name"
            , 4.0
            )
        ,
            ( "hs-source-dirs"
            , 5.0
            )
        ,
            ( "version"
            , 6.0
            )
        ,
            ( "build-depends"
            , 7.0
            )
        ,
            ( "exposed-modules"
            , 8.0
            )
        ,
            ( "license"
            , 9.0
            )
        ,
            ( "license-file"
            , 10.0
            )
        ,
            ( "other-modules"
            , 11.0
            )
        ,
            ( "copyright"
            , 12.0
            )
        ,
            ( "category"
            , 13.0
            )
        ,
            ( "author"
            , 14.0
            )
        ,
            ( "default-extensions"
            , 15.0
            )
        ,
            ( "ghc-options"
            , 16.0
            )
        ,
            ( "maintainer"
            , 17.0
            )
        ,
            ( "homepage"
            , 18.0
            )
        ,
            ( "bug-reports"
            , 19.0
            )
        ,
            ( "synopsis"
            , 20.0
            )
        ,
            ( "description"
            , 21.0
            )
        ,
            ( "build-type"
            , 22.0
            )
        ,
            ( "tested-with"
            , 23.0
            )
        ,
            ( "extra-doc-files"
            , 24.0
            )
        ,
            ( "source-repository"
            , 25.0
            )
        ,
            ( "type"
            , 26.0
            )
        ,
            ( "common"
            , 27.0
            )
        ,
            ( "location"
            , 28.0
            )
        ,
            ( "library"
            , 29.0
            )
        ,
            ( "executable"
            , 30.0
            )
        ,
            ( "test-suite"
            , 31.0
            )
        ]
    , fixBuildDeps = True
    , depAlignment = DepAligned
    , removeBlankFields = True
    , valueAligned = ValueUnaligned
    , sectionMargin = Margin
    , commentMargin = NoMargin
    , narrowN = 60
    , indentN = 4
    }
#+end_example

* Archive exploration

#+begin_src haskell-ng :results output
:r
:set -Wno-type-defaults
:set -Wno-name-shadowing
:set -XOverloadedStrings
import Data.Char
import CabalFix
import CabalFix.Archive
import qualified Codec.Archive.Tar as Tar
import System.Directory
import Control.Monad
import Data.List qualified as List
import Data.Function
import Box
import Data.Bifunctor
import Data.ByteString (ByteString)
import Data.ByteString qualified as BS
import Data.ByteString.Lazy qualified as BSL
import Data.ByteString.Char8 qualified as C
import FlatParse.Basic qualified as FP
import NumHask.Space
import Data.Map.Strict qualified as Map
import Data.Ord
import Data.Either
import Algebra.Graph
import qualified Algebra.Graph.ToGraph as ToGraph
import DotParse
import Chart
import Data.Set qualified as Set
import Text.Pretty.Simple
#+end_src

#+RESULTS:
: Ok, three modules loaded.


* State

#+begin_src haskell :results output
vlibs <- Map.delete "acme-everything" <$> validLatestLibs
deps = fmap fst . runParser_ (FP.many depP) . mconcat . mconcat . rawBuildDeps . snd <$> vlibs
bdnames = List.nub $ mconcat $ fmap snd $ Map.toList deps
depsExclude = filter (not . (`elem` (Map.keys vlibs))) bdnames
vdeps = fmap (filter (not . (`elem` depsExclude))) deps
depG = stars (Map.toList vdeps)
Map.size vdeps
Map.size vlibs
vertexCount depG
#+end_src

#+RESULTS:
: 15711
: 15711
: 15711

* tar development
** entries
#+begin_src haskell :results output
Tar.entryPath <$> take 5 es
#+end_src

#+RESULTS:
: ["iconv/0.2/iconv.cabal","Crypto/3.0.3/Crypto.cabal","HDBC/1.0.1/HDBC.cabal","HDBC-odbc/1.0.1.0/HDBC-odbc.cabal","HDBC-postgresql/1.0.1.0/HDBC-postgresql.cabal"]


3 seconds

#+begin_src haskell :results output
length es
#+end_src

#+RESULTS:
: 310933


#+begin_src haskell :results output
(length $ filter (isNormalFile . Tar.entryContent) es) == length es
#+end_src

#+RESULTS:
: True

** Maximum file size:

#+begin_src haskell :results output
(\xs -> filter ((maximum (snd <$> xs) ==) . snd) xs) $ [(fp,x) | (fp, Tar.NormalFile _ x) <- (\e -> (Tar.entryPath e, Tar.entryContent e)) <$> es]
#+end_src

#+RESULTS:
: [("acme-everything/2018.11.18/acme-everything.cabal",261865)]

** zero size

#+begin_src haskell :results output
(\xs -> filter ((0 ==) . snd) xs) $ [(fp,x) | (fp, Tar.NormalFile _ x) <- (\e -> (Tar.entryPath e, Tar.entryContent e)) <$> es]
#+end_src

#+RESULTS:
: [("lzma/preferred-versions",0),("signal/preferred-versions",0),("peyotls-codec/preferred-versions",0),("th-orphans/preferred-versions",0),("GPipe/preferred-versions",0),("GPipe/preferred-versions",0),("base-orphans/preferred-versions",0),("MailchimpSimple/preferred-versions",0),("warp/preferred-versions",0),("table-layout/preferred-versions",0),("d3d11binding/preferred-versions",0),("shakespeare-sass/preferred-versions",0),("kawhi/preferred-versions",0),("hip/preferred-versions",0),("lowgl/preferred-versions",0),("lowgl/preferred-versions",0),("NetSNMP/preferred-versions",0),("xml-conduit/preferred-versions",0),("penrose/preferred-versions",0),("aeson-diff/preferred-versions",0),("milena/preferred-versions",0),("hruby/preferred-versions",0),("hruby/preferred-versions",0),("parsec/preferred-versions",0),("qchas/preferred-versions",0),("monadiccp/preferred-versions",0),("preprocessor-tools/preferred-versions",0),("line-bot-sdk/preferred-versions",0),("debug-dump/preferred-versions",0),("microlens-process/preferred-versions",0),("doldol/preferred-versions",0),("doldol/preferred-versions",0),("tensorflow-core-ops/preferred-versions",0),("bitwise-enum/preferred-versions",0),("bitwise-enum/preferred-versions",0),("simple-cabal/preferred-versions",0),("zip/preferred-versions",0),("shake-plus/preferred-versions",0),("tasty-html/preferred-versions",0),("logict/preferred-versions",0),("hw-kafka-client/preferred-versions",0),("geojson/preferred-versions",0),("dialogue/preferred-versions",0),("scalendar/preferred-versions",0)]

** preferred-versions

[[https://hackage.haskell.org/package/Cabal/preferred][Cabal: preferred and deprecated versions | Hackage]]

#+begin_src haskell :results output
take 3 $ (\xs -> filter ((List.isSuffixOf "preferred-versions") . fst) xs) $ [(fp,bs) | (fp, Tar.NormalFile bs _) <- (\e -> (Tar.entryPath e, Tar.entryContent e)) <$> es]
#+end_src

#+RESULTS:
: [("ADPfusion/preferred-versions","ADPfusion <0.4.0.0 || >0.4.0.0"),("AesonBson/preferred-versions","AesonBson <0.2.0 || >0.2.0 && <0.2.1 || >0.2.1"),("BiobaseXNA/preferred-versions","BiobaseXNA <0.9.1.0 || >0.9.1.0")]

#+begin_src haskell :results output
length $ (\xs -> filter ((List.isSuffixOf "preferred-versions") . fst) xs) $ [(fp,bs) | (fp, Tar.NormalFile bs _) <- (\e -> (Tar.entryPath e, Tar.entryContent e)) <$> es]
#+end_src

#+RESULTS:
: 3280

** package.json

=package-json= content is a security/signing feature you can read about in [[https://github.com/haskell/hackage-security/blob/master/README.md][hackage-security]].

#+begin_src haskell :results output
length $ filter ((== "package.json") . filenameFN . runP filenameP . FP.strToUtf8 . fst) $ filter (not . (List.isSuffixOf "preferred-versions") . fst) $ [(fp,bs) | (fp, Tar.NormalFile bs _) <- (\e -> (Tar.entryPath e, Tar.entryContent e)) <$> es]
#+end_src

#+RESULTS:
: 134994

** filename conventions

Either *.cabal, preferred_version or package.json

#+begin_src haskell :results output
filename . FP.strToUtf8 . fst <$> take 20 rs
#+end_src

#+RESULTS:
: [FileName {name = "iconv", version = "0.2", fileName = "iconv.cabal"},FileName {name = "Crypto", version = "3.0.3", fileName = "Crypto.cabal"},FileName {name = "HDBC", version = "1.0.1", fileName = "HDBC.cabal"},FileName {name = "HDBC-odbc", version = "1.0.1.0", fileName = "HDBC-odbc.cabal"},FileName {name = "HDBC-postgresql", version = "1.0.1.0", fileName = "HDBC-postgresql.cabal"},FileName {name = "HDBC-sqlite3", version = "1.0.1.0", fileName = "HDBC-sqlite3.cabal"},FileName {name = "darcs-graph", version = "0.1", fileName = "darcs-graph.cabal"},FileName {name = "hask-home", version = "2006.3.23", fileName = "hask-home.cabal"},FileName {name = "hmp3", version = "1.1", fileName = "hmp3.cabal"},FileName {name = "lambdabot", version = "4.0", fileName = "lambdabot.cabal"},FileName {name = "parsedate", version = "2006.6.4", fileName = "parsedate.cabal"},FileName {name = "plugins", version = "1.0", fileName = "plugins.cabal"},FileName {name = "zlib", version = "0.2", fileName = "zlib.cabal"},FileName {name = "bzlib", version = "0.2", fileName = "bzlib.cabal"},FileName {name = "libxml", version = "0.1", fileName = "libxml.cabal"},FileName {name = "xslt", version = "0.1", fileName = "xslt.cabal"},FileName {name = "hxweb", version = "0.1", fileName = "hxweb.cabal"},FileName {name = "HGL", version = "3.1", fileName = "HGL.cabal"},FileName {name = "GLUT", version = "2.0", fileName = "GLUT.cabal"},FileName {name = "HUnit", version = "1.1", fileName = "HUnit.cabal"}]

#+begin_src haskell :results output
take 20 $ filter ((/="package.json") . fileName) $ filter (\f -> (CabalFix.Archive.name f <> ".cabal") /= (fileName f)) $ filename . FP.strToUtf8 . fst <$> rs
#+end_src

#+RESULTS:
: []

#+begin_src haskell :results output
take 2 $ filter ((/="package.json") . fileName . filename . FP.strToUtf8 . fst) $ rs
#+end_src

** version ranges

#+begin_src haskell :results output
length $ (CabalFix.Archive.version . versionFN . filename . FP.strToUtf8 . fst) <$> rs
#+end_src

#+RESULTS:
: 134994

#+begin_src haskell :results output
mVersions = Map.fromListWith (<>) $ ((\x -> (nameFN x, (:[]) $ CabalFix.Archive.version (versionFN x))) . filename . FP.strToUtf8 . fst) <$> rs
#+end_src

#+RESULTS:

#+begin_src haskell :results output
join $ space1 <$> Map.lookup "chart-svg" mVersions :: (Maybe (RangeEP Version))
#+end_src

#+RESULTS:
: Just (RangeEP {rangeEP = Range Version [0,0,1] Version [0,5,1,0], lowerEP = Opened, upperEP = Opened})

#+begin_src haskell :results output
x1 = fromMaybe undefined $ join $ space1 <$> Map.lookup "chart-svg" mVersions :: (RangeEP Version)
#+end_src

#+RESULTS:

#+begin_src haskell :results output
x1 = fromMaybe undefined $ Map.lookup "chart-svg" mVersions
x1
#+end_src

#+RESULTS:
: [Version [0,5,1,0],Version [0,5,0,0],Version [0,4,1,1],Version [0,4,1,0],Version [0,4,0],Version [0,3,3],Version [0,3,2],Version [0,3,1],Version [0,3,0],Version [0,2,3],Version [0,2,2],Version [0,2,1],Version [0,2,0],Version [0,1,3],Version [0,1,2],Version [0,1,1],Version [0,1,0],Version [0,0,3],Version [0,0,2],Version [0,0,1]]

#+begin_src haskell :results output
minimum x1
#+end_src

#+RESULTS:
: Version [0,0,1]

**** all versions are unique?

#+begin_src haskell :results output
take 10 $ Map.toList $ Map.filter (\a -> length a /= length (List.nub a)) mVersions
#+end_src

#+RESULTS:
: []

**** Version counts

#+begin_src haskell :results output
take 10 $ List.sortOn (Down . snd) $ Map.toList $ Map.map length mVersions
#+end_src

#+RESULTS:
: [("haskoin-store",293),("git-annex",278),("hlint",221),("yesod-core",213),("warp",201),("purescript",200),("egison",190),("hakyll",190),("pandoc",187),("persistent",184)]

** latest cabals

#+begin_src haskell :results output
getVersion = runP versionP . versionFN . filename . FP.strToUtf8 . fst
mLatest = Map.fromListWith (\v v' -> bool v' v (getVersion v > getVersion v')) $ (\x -> (nameFN . filename . FP.strToUtf8 . fst $ x, x)) <$> rs
#+end_src

#+RESULTS:

#+begin_src haskell :results output
length $ (second fst <$> (Map.toList $ mLatest))
#+end_src

#+RESULTS:
: 17445

** readFields

A few packages give a bad readFields

#+begin_src haskell :results output
Map.map fst $ Map.filter (isLeft . readFields . BSL.toStrict . snd) $ mLatest -- readFields
#+end_src

#+RESULTS:
: fromList [("DSTM","DSTM/0.1.2/DSTM.cabal"),("control-monad-exception-mtl","control-monad-exception-mtl/0.10.3/control-monad-exception-mtl.cabal"),("ds-kanren","ds-kanren/0.2.0.1/ds-kanren.cabal"),("metric","metric/0.2.0/metric.cabal"),("phasechange","phasechange/0.1/phasechange.cabal"),("smartword","smartword/0.0.0.5/smartword.cabal")]

#+RESULTS:


** field counts
*** author

#+begin_src haskell :results output
take 40 $ List.sortOn (Down . snd) $ Map.toList $ count_ $ mconcat $ fmap snd $ Map.toList $ Map.map (mconcat . fmap author . snd) vlls
#+end_src

#+RESULTS:
: [("Brendan Hay",529),("Nikita Volkov <nikita.y.volkov@mail.ru>",148),("Tom Sydney Kerckhove",119),("Andrew Martin",110),("Edward A. Kmett",99),("OleksandrZhabenko",88),("Henning Thielemann <haskell@henning-thielemann.de>",87),("Michael Snoyman",83),("Daniel Firth",80),("M Farkas-Dyck",79),("Vanessa McHale",75),("Vincent Hanquez <vincent@snarc.org>",63),("Chris Martin",61),("Oleg Grenrus <oleg.grenrus@iki.fi>",59),("Renzo Carbonara",57),("Michael Snoyman <michael@snoyman.com>",52),("Tony Morris <\202\135\199\157u\203\153s\196\177\201\185\201\185o\201\175\202\135@\215\159\215\159\199\157\202\158s\201\144\201\165>",50),("I\195\177aki Garc\195\173a Etxebarria",48),("chessai",48),("Fumiaki Kinoshita",47),("John Ky",46),("Ian Duncan",45),("Chris Done",42),("Athan Clark",39),("Chris Penner",36),("Jeremy Shaw",35),("Kazu Yamamoto <kazu@iij.ad.jp>",35),("Bryan O'Sullivan <bos@serpentine.com>",34),("Herbert Valerio Riedel",34),("John Wiegley",34),("Torsten Schmits",34),("Marco Zocca",33),("Jakub Waszczuk",32),("Jinjing Wang",32),("Rohan Drape",32),("HirotomoMoriwaki<philopon.dependence@gmail.com>",31),("James Cook <mokus@deepbondi.net>",31),("Jonathan Fischoff",31),("Justin Le",30),("Obsidian Systems LLC",30)]

*** libraries

not libraries

#+begin_src haskell :exports both
Map.size $ Map.filter ((0==) . length) $ fmap (catMaybes . fmap (sec "library") . snd) vlls
#+end_src

#+RESULTS:
: 0

multiple libraries

#+begin_src haskell :exports both
Map.size $ Map.filter ((>1) . length) $ fmap (catMaybes . fmap (sec "library") . snd) vlls
#+end_src

#+RESULTS:
: 89

Multiple libraries are usually "internal" libraries that can only be used inside the cabal file.

#+begin_src haskell :results output
take 10 $ Map.toList $ Map.filter (\x -> x/=[[]] && x/=[] && listToMaybe x /= Just []) $ fmap (fmap (fmap secName) . fmap fst . catMaybes . fmap (sec "library") . snd) vlls
#+end_src

#+RESULTS:
: [("LiterateMarkdown",[[("name","converter")]]),("attoparsec",[[("name","attoparsec-internal")],[]]),("balkon",[[("name","balkon-internal")],[]]),("buffet",[[("name","buffet-internal")]]),("cabal-fmt",[[("name","version-interval")],[("name","cabal-fmt-internal")]]),("cuckoo",[[("name","random-internal")],[]]),("dhrun",[[("name","dhrun-lib")]]),("escoger",[[("name","escoger-lib")]]),("ghc-plugs-out",[[("name","no-op-plugin")],[("name","undefined-init-plugin")],[("name","undefined-solve-plugin")],[("name","undefined-stop-plugin")],[("name","call-count-plugin")]]),("hackage-cli",[[("name","cabal-revisions")]])]

*** common stanzas

#+begin_src haskell :exports both
length $ Map.toList $ Map.filter (/=[]) $ fmap (catMaybes . fmap (sec "common")) $ fmap snd vlls
#+end_src

#+RESULTS:
: 817

valid cabal files that have a library section:

#+begin_src haskell :exports both
vlibs <- Map.delete "acme-everything" <$> validLatestLibs
Map.size vlibs
#+end_src

#+RESULTS:
: 15711

** dependencies

Total number of build dependencies in library stanzas and in common stanzas:

#+begin_src haskell :results output :exports both
sum $ fmap snd $ Map.toList $ fmap (sum . fmap length) $ fmap (fmap (fieldValues "build-depends")) $ Map.filter (/=[]) $ fmap (fmap snd . catMaybes . fmap (sec "library") . snd) vlibs

sum $ fmap snd $ Map.toList $ fmap (sum . fmap length) $ fmap (fmap (fieldValues "build-depends")) $ Map.filter (/=[]) $ fmap (fmap snd . catMaybes . fmap (sec "common") . snd) vlibs
#+end_src

#+RESULTS:
: 103777
: > 4345


no dependencies

#+begin_src haskell :exports both
Map.size $ Map.filter (==[]) $ fmap (rawBuildDeps . snd) $ vlibs
#+end_src

#+RESULTS:
: 0

unique dependencies

#+begin_src haskell
Map.size $ fmap (fmap mconcat) $ Map.filter (/=[]) $ fmap (rawBuildDeps . snd) $ vlibs
#+end_src

#+RESULTS:
: 15711


raw build-deps example:

#+begin_src haskell :exports both
take 1 $ Map.toList $ fmap (fmap mconcat) $ Map.filter (/=[]) $ fmap (rawBuildDeps . snd) $ vlibs
#+end_src

#+RESULTS:
| 2captcha | (aeson >=1.5.6.0 && <1.6,base >=4.7 && <5,bytestring >=0.10.12.0 && <0.11,clock >=0.8.2 && <0.9,exceptions >=0.10.4 && <0.11,http-client >=0.6.4.1 && <0.7,lens >=4.19.2 && <4.20,lens-aeson >=1.1.1 && <1.2,parsec >=3.1.14.0 && <3.2,text >=1.2.4.1 && <1.3,wreq >=0.5.3.3 && <0.6 ) |

lex check:

#+begin_src haskell :exports both
count_ $ mconcat $ C.unpack <$> (mconcat $ fmap snd $ Map.toList $ fmap (fmap mconcat) $ Map.filter (/=[]) $ fmap (rawBuildDeps . snd) $ vlibs)
#+end_src

#+RESULTS:
: fromList [('\t',42),(' ',613471),('&',92586),('(',406),(')',406),('*',6131),(',',99089),('-',34798),('.',151089),('0',83272),('1',67896),('2',36311),('3',21528),('4',31320),('5',23732),('6',10261),('7',10046),('8',6972),('9',6851),(':',14),('<',48417),('=',83864),('>',69505),('A',268),('B',250),('C',1164),('D',478),('E',76),('F',144),('G',346),('H',826),('I',103),('J',118),('K',15),('L',512),('M',404),('N',79),('O',288),('P',437),('Q',631),('R',247),('S',559),('T',540),('U',202),('V',75),('W',74),('X',92),('Y',24),('Z',17),('^',3550),('a',78888),('b',31479),('c',38321),('d',21422),('e',116357),('f',13092),('g',17571),('h',17821),('i',56079),('j',560),('k',8075),('l',36458),('m',27855),('n',57977),('o',50979),('p',30459),('q',2559),('r',71441),('s',83946),('t',95874),('u',14974),('v',7119),('w',4030),('x',10866),('y',19248),('z',1673),('{',100),('|',2386),('}',100)]

** deps

*** parse error check

Looks like no leftovers and no errors

#+begin_src haskell :results output
import Data.These
take 3 $ Map.toList $ Map.filter (not . these (const False) (const True) (const (const False)) . runParserWarn (FP.many depP) . mconcat . mconcat . rawBuildDeps . snd) vlibs
#+end_src

#+RESULTS:
: []

#+begin_src haskell :results output
take 4 $ Map.toList $ runParser_ (FP.many depP) . mconcat . mconcat . rawBuildDeps . snd <$> vlibs
#+end_src

#+RESULTS:
: [("2captcha",[("aeson",">=1.5.6.0 && <1.6"),("base",">=4.7 && <5"),("bytestring",">=0.10.12.0 && <0.11"),("clock",">=0.8.2 && <0.9"),("exceptions",">=0.10.4 && <0.11"),("http-client",">=0.6.4.1 && <0.7"),("lens",">=4.19.2 && <4.20"),("lens-aeson",">=1.1.1 && <1.2"),("parsec",">=3.1.14.0 && <3.2"),("text",">=1.2.4.1 && <1.3"),("wreq",">=0.5.3.3 && <0.6")]),("3dmodels",[("base",">=4.7 && <4.8"),("attoparsec",">=0.12 && <0.13"),("bytestring",">=0.10 && <0.11"),("linear",">=1.10 && <1.11"),("packer",">=0.1 && <0.2")]),("AAI",[("base",">=4.8 && <4.9")]),("ABList",[("base","< 5 && >= 3"),("linear",""),("newtype","")])]

#+begin_src haskell :results output
take 4 $ Map.toList $ fmap (second (simpleParsecBS :: ByteString -> Maybe VersionRange)) . runParser_ (FP.many depP) . mconcat . mconcat . rawBuildDeps . snd <$> vlibs
#+end_src

#+RESULTS:
: [("2captcha",[("aeson",Just (IntersectVersionRanges (OrLaterVersion (mkVersion [1,5,6,0])) (EarlierVersion (mkVersion [1,6])))),("base",Just (IntersectVersionRanges (OrLaterVersion (mkVersion [4,7])) (EarlierVersion (mkVersion [5])))),("bytestring",Just (IntersectVersionRanges (OrLaterVersion (mkVersion [0,10,12,0])) (EarlierVersion (mkVersion [0,11])))),("clock",Just (IntersectVersionRanges (OrLaterVersion (mkVersion [0,8,2])) (EarlierVersion (mkVersion [0,9])))),("exceptions",Just (IntersectVersionRanges (OrLaterVersion (mkVersion [0,10,4])) (EarlierVersion (mkVersion [0,11])))),("http-client",Just (IntersectVersionRanges (OrLaterVersion (mkVersion [0,6,4,1])) (EarlierVersion (mkVersion [0,7])))),("lens",Just (IntersectVersionRanges (OrLaterVersion (mkVersion [4,19,2])) (EarlierVersion (mkVersion [4,20])))),("lens-aeson",Just (IntersectVersionRanges (OrLaterVersion (mkVersion [1,1,1])) (EarlierVersion (mkVersion [1,2])))),("parsec",Just (IntersectVersionRanges (OrLaterVersion (mkVersion [3,1,14,0])) (EarlierVersion (mkVersion [3,2])))),("text",Just (IntersectVersionRanges (OrLaterVersion (mkVersion [1,2,4,1])) (EarlierVersion (mkVersion [1,3])))),("wreq",Just (IntersectVersionRanges (OrLaterVersion (mkVersion [0,5,3,3])) (EarlierVersion (mkVersion [0,6]))))]),("3dmodels",[("base",Just (IntersectVersionRanges (OrLaterVersion (mkVersion [4,7])) (EarlierVersion (mkVersion [4,8])))),("attoparsec",Just (IntersectVersionRanges (OrLaterVersion (mkVersion [0,12])) (EarlierVersion (mkVersion [0,13])))),("bytestring",Just (IntersectVersionRanges (OrLaterVersion (mkVersion [0,10])) (EarlierVersion (mkVersion [0,11])))),("linear",Just (IntersectVersionRanges (OrLaterVersion (mkVersion [1,10])) (EarlierVersion (mkVersion [1,11])))),("packer",Just (IntersectVersionRanges (OrLaterVersion (mkVersion [0,1])) (EarlierVersion (mkVersion [0,2]))))]),("AAI",[("base",Just (IntersectVersionRanges (OrLaterVersion (mkVersion [4,8])) (EarlierVersion (mkVersion [4,9]))))]),("ABList",[("base",Just (IntersectVersionRanges (EarlierVersion (mkVersion [5])) (OrLaterVersion (mkVersion [3])))),("linear",Nothing),("newtype",Nothing)])]

#+begin_src haskell :results output
FP.runParser (FP.many depP) "base >= 4 && < 6,parallel > 3.1,array >= 0.2.0.0,directory >= 1 && < 2,mtl >= 1.1.0,carray >= 0.1.5,QuickCheck >= 2.1,containers >= 0.2,storable-complex,binary >= 0.5,deepseq >= 1.1,bindings-DSL >= 1.0.14 && < 1.1,vector >= 0.7.0.1 && < 1.1,lazysmallcheck >= 0.5 && < 1,parallel-io    >= 0.3.2 && < 0.3.3,storable-tuple >= 0.0.2 && <= 1,mwc-random >= 0.12.0.0,primitive  >= 0.4.1, filepath >= 1.3.0.0 && < 1.4"
#+end_src

#+RESULTS:
: OK [("base",">= 4 && < 6"),("parallel","> 3.1"),("array",">= 0.2.0.0"),("directory",">= 1 && < 2"),("mtl",">= 1.1.0"),("carray",">= 0.1.5"),("QuickCheck",">= 2.1"),("containers",">= 0.2"),("storable-complex",""),("binary",">= 0.5"),("deepseq",">= 1.1"),("bindings-DSL",">= 1.0.14 && < 1.1"),("vector",">= 0.7.0.1 && < 1.1"),("lazysmallcheck",">= 0.5 && < 1"),("parallel-io",">= 0.3.2 && < 0.3.3"),("storable-tuple",">= 0.0.2 && <= 1"),("mwc-random",">= 0.12.0.0"),("primitive",">= 0.4.1"),("filepath",">= 1.3.0.0 && < 1.4")] ""

#+begin_src haskell :results output
FP.runParser (FP.many depP) ",LambdaHack >= 0.11.0.0 && < 0.11.1.0,async,base >= 4.10 && < 99,enummapset,file-embed >= 0.0.11,filepath,hsini,ghc-compact,optparse-applicative,primitive,splitmix,template-haskell,text,th-lift-instances,transformers"
#+end_src

#+RESULTS:
: OK [("LambdaHack",">= 0.11.0.0 && < 0.11.1.0"),("async",""),("base",">= 4.10 && < 99"),("enummapset",""),("file-embed",">= 0.0.11"),("filepath",""),("hsini",""),("ghc-compact",""),("optparse-applicative",""),("primitive",""),("splitmix",""),("template-haskell",""),("text",""),("th-lift-instances",""),("transformers","")] ""

*** deps - Map of dependencies

#+begin_src haskell :results output :exports both
deps = fmap fst . runParser_ (FP.many depP) . mconcat . mconcat . rawBuildDeps . snd <$> vlibs
Map.size deps
sum $ Map.elems $ fmap length deps
#+end_src

#+RESULTS:
: 15711
: 113577

#+begin_src haskell :results output :exports both
take 3 $ Map.toList deps
#+end_src

#+RESULTS:
: [("2captcha",["aeson","base","bytestring","clock","exceptions","http-client","lens","lens-aeson","parsec","text","wreq"]),("3dmodels",["base","attoparsec","bytestring","linear","packer"]),("AAI",["base"])]

packages with the most dependencies:

#+begin_src haskell :exports both
take 20 $ List.sortOn (Down . snd) $ fmap (second length) $ Map.toList deps
#+end_src

#+RESULTS:
| hackport        | 132 |
| yesod-platform  | 132 |
| planet-mitchell | 109 |
| raaz            | 104 |
| pantry          |  98 |
| hevm            |  90 |
| sockets         |  82 |
| spotify         |  77 |
| btc-lsp         |  71 |
| pandoc          |  70 |
| too-many-cells  |  70 |
| ghcide          |  69 |
| cachix          |  68 |
| sprinkles       |  67 |
| emanote         |  66 |
| freckle-app     |  66 |
| pantry-tmp      |  64 |
| swarm           |  64 |
| taffybar        |  63 |
| neuron          |  61 |

dependees

#+begin_src haskell :results output
take 20 $ List.sortOn (Down . snd) $ Map.toList $ count_ $ mconcat $ fmap snd $ Map.toList deps
#+end_src

#+RESULTS:
: [("base",15111),("bytestring",5494),("text",5070),("containers",4808),("mtl",3514),("transformers",3111),("aeson",2069),("time",1975),("vector",1835),("directory",1632),("filepath",1556),("template-haskell",1474),("unordered-containers",1414),("deepseq",1271),("lens",1189),("binary",947),("hashable",943),("array",901),("exceptions",871),("process",852)]

All the dependees found:

#+begin_src haskell :results output
bdnames = List.nub $ mconcat $ fmap snd $ Map.toList deps
length bdnames
#+end_src

#+RESULTS:
: 5982

*** dependency name errors

dependees not in the cabal index:

#+begin_src haskell :results output :exports both
length $ filter (not . (`elem` (Map.keys vlibs))) bdnames

take 10 $ filter (not . (`elem` (Map.keys vlibs))) bdnames

#+end_src

#+RESULTS:
: 260
: ["html","NewBinary","prettyclass","lazysmallcheck","Stream","MaybeT","chunks","hinstaller","mmtl","peanoalg"]

excluding these:

#+begin_src haskell :results output :exports both
depsExclude = filter (not . (`elem` (Map.keys vlibs))) bdnames
vdeps = fmap (filter (not . (`elem` depsExclude))) deps
Map.size vdeps
sum $ fmap snd $ Map.toList $ fmap length vdeps
#+end_src

#+RESULTS:
: 15711
: 112974

*** potential error sources

- [X] error 1 - commas can be inside braces

- [ ] error 2 - plain old dodgy depends
  acme-everything, cabal, deprecated packages

- [ ] error 3 - multiple build-depends in one stanza

- [ ] error 4 - cpp & conditionals

- [ ] error 5 - packages not on Hackage

   cardano
   "This library requires quite a few exotic dependencies from the cardano realm which aren't necessarily on hackage nor stackage. The dependencies are listed in stack.yaml, make sure to also include those for importing cardano-transactions." ~ https://raw.githubusercontent.com/input-output-hk/cardano-haskell/d80bdbaaef560b8904a828197e3b94e667647749/snapshots/cardano-1.24.0.yaml

- [ ] error 6 - internal library (only available to the main cabal library stanza)
  yahoo-prices, vector-endian, symantic-parser

Empty lists are mostly due to bad conditional parsing

 #+begin_src haskell :exports both
 Map.size $ Map.filter null deps
 #+end_src

 #+RESULTS:
 : 267

** algebraic-graphs

An (algebraic) graph of dependencies:

#+begin_src haskell :results output
depG = stars (Map.toList vdeps)
#+end_src

#+RESULTS:

#+begin_src haskell
:t depG
#+end_src

#+RESULTS:
: depG :: Graph ByteString

#+begin_src haskell
ToGraph.preSet "folds" depG
#+end_src

#+RESULTS:
: fromList ["folds-common","online","proton"]

#+begin_src haskell
ToGraph.postSet "folds" depG
#+end_src

#+RESULTS:
: fromList ["adjunctions","base","bifunctors","comonad","constraints","contravariant","data-reify","distributive","lens","mtl","pointed","profunctors","reflection","semigroupoids","transformers","unordered-containers","vector"]

#+begin_src haskell :results output :exports both
vertexCount depG
edgeCount depG
#+end_src

#+RESULTS:
: 15711
: 112169

** graphics

=text= package dependency example

#+begin_src haskell
supers = upstreams "text" depG <> Set.singleton "text"
 superG = induce (`elem` (toList supers)) depG
 #+end_src

#+RESULTS:

#+begin_src haskell :file other/textdeps.svg :results output graphics file :exports results
 baseGraph = defaultGraph & attL NodeType (ID "shape") .~ Just (ID "box") & gattL (ID "rankdir") .~ Just (IDQuoted "BT")
 g <- processGraph $ toDotGraphWith UnDirected baseGraph superG
 writeChartOptions "other/textdeps.svg" (graphToChart g)
 #+end_src

#+RESULTS:
[[file:other/textdeps.svg]]

=folds=

#+begin_src haskell
 supers = upstreams "folds" depG <> Set.singleton "folds"
 superG = induce (`elem` (toList supers)) depG
 #+end_src

 #+RESULTS:


#+begin_src haskell :file other/foldsdeps.svg :results output graphics file :exports results
 baseGraph = defaultGraph & attL NodeType (ID "shape") .~ Just (ID "box") & gattL (ID "rankdir") .~ Just (IDQuoted "BT")
 g <- processGraph $ toDotGraphWith UnDirected baseGraph superG
 writeChartOptions "other/foldsdeps.svg" (graphToChart g)
 #+end_src

 #+RESULTS:
 [[file:other/foldsdeps.svg]]


=mealy= package dependencies

#+begin_src haskell
 supers = upstreams "mealy" depG <> Set.singleton "mealy"
 superG = induce (`elem` (toList (Set.delete "base" supers))) depG
 #+end_src

#+RESULTS:

#+begin_src haskell :file other/mealy.svg :results output graphics file :exports results
 g <- processGraph $ toDotGraphWith UnDirected baseGraph superG
 writeChartOptions "other/mealy.svg" (graphToChart g)
 #+end_src

 #+RESULTS:
 [[file:other/mealy.svg]]

* Retrieve test cabals

#+begin_src haskell :results output
cs <- getTestCabals
cs' = Map.fromList cs
bs = fromMaybe (error "bad lookup") $ Map.lookup "numhask.cabal" cs'
#+end_src

#+RESULTS:

rerender and save as a file

#+begin_src haskell :results output
fst <$> cs
#+end_src

#+RESULTS:
: ["tonyday567.cabal","research-hackage.cabal","anal.cabal","numhask-array.cabal","chart-svg.cabal","cabal-fix.cabal","numhask-space.cabal","mealy.cabal","formatn.cabal","prettychart.cabal","dotparse.cabal","perf.cabal","numhask.cabal","ephemeral.cabal","box-socket.cabal","iqfeed.cabal","box.cabal","code.cabal","foo.cabal","web-rep.cabal","poker-fold.cabal"]

#+begin_src haskell :results output
void $ mapM (\(fp,bs) -> BS.writeFile ("/Users/tonyday/haskell/cabal-fix/test/rendered/" <> fp) bs) (second (cabalFix (defaultConfig)) <$> cs)
#+end_src

#+RESULTS:

** cabalFix idempotence

#+begin_src haskell :results output
xs <- getTestCabals
#+end_src

#+RESULTS:

#+begin_src haskell :results output
xs' = (second (cabalFix (defaultConfig)) <$> xs)
xs' == (second (cabalFix (defaultConfig)) <$> xs')
#+end_src

#+RESULTS:
: True

* Diff

#+begin_src haskell :results output
import Data.Algorithm.DiffOutput
prettyDiffs $ diffToLineRanges $ getGroupedDiff (C.unpack <$> C.dropWhile isSpace <$> (C.lines bs)) (C.unpack <$> C.dropWhile isSpace <$> (C.lines $ cabalFix bs))

#+end_src

#+RESULTS:
: 1a2
: 21d21
: <
: 35c35,36
: < import: lang
: ---
: import:
: lang
: 46a48

* all the cabals

#+begin_src haskell :results output
allCabalProjects "/Users/tonyday/haskell"
#+end_src

#+RESULTS:
: ["numhask","eulerproject","mealy","box","formatn","prettychart","cabal-fix","code","poker-fold","numhask-space","iqfeed","box-socket","numhask-array","tonyday567","foo","web-rep","baz","dotparse","perf","anal","research-hackage","chart-svg","ephemeral"]

#+begin_src haskell :results output
cs <- allCabals "/Users/tonyday/haskell"
:t cs
#+end_src

#+RESULTS:
: cs :: [(String, ByteString)]

** write all the cabals

#+begin_src haskell :results output
cs <- getCabalFiles "/Users/tonyday/haskell/cabal-fix/test/rendered/"
ns = takeWhile (/='.') . fst <$> cs
ns
#+end_src

#+RESULTS:
: ["tonyday567","research-hackage","anal","numhask-array","chart-svg","cabal-fix","numhask-space","mealy","formatn","prettychart","dotparse","perf","numhask","ephemeral","box-socket","iqfeed","box","code","foo","web-rep","poker-fold"]

#+begin_src haskell :results output
sequence_ (zipWith (\n bs -> BS.writeFile ("/Users/tonyday/haskell/" <> n <> "/" <> n <> ".cabal") bs) ns (snd <$> cs))
#+end_src

#+RESULTS:

* writing licenses

#+begin_src haskell :results output
ps <- allCabalProjects "/Users/tonyday/haskell"
#+end_src

#+RESULTS:

#+begin_src haskell :results output
ps
#+end_src

#+RESULTS:
: ["numhask","mealy","box","formatn","prettychart","cabal-fix","code","poker-fold","numhask-space","iqfeed","box-socket","numhask-array","tonyday567","foo","web-rep","baz","dotparse","perf","anal","research-hackage","chart-svg","ephemeral"]

#+begin_src haskell :results output
sequence_ $ fromMaybe (pure ()) . (\p -> BS.writeFile ("/Users/tonyday/haskell/" <> p <> "/" <> "LICENSE") . C.pack . licenseFile "Tony Day" . show <$> (Map.lookup p (Map.fromList yearList))) <$> ps
#+end_src

#+RESULTS:

* categories

#+begin_src haskell :results output
myCats = first (takeWhile (/='.')) . second ((maybe "" (\(Field _ ((FieldLine _ c:_))) -> c)) . listToMaybe . filter (hasName ["category"]) . toFields) <$> cs
#+end_src

#+RESULTS:

#+begin_src haskell :results output
myCats
#+end_src

#+RESULTS:
: [("tonyday567","project"),("research-hackage","project"),("anal","project"),("numhask-array","project"),("chart-svg","charts"),("cabal-fix","project"),("numhask-space","mathematics"),("mealy","folding"),("formatn","Development"),("prettychart","project"),("dotparse","project"),("perf","project"),("numhask","mathematics"),("ephemeral","project"),("box-socket","project"),("iqfeed","API"),("box","project"),("code","project"),("foo",""),("web-rep","web"),("poker-fold","project")]

#+begin_src haskell :results output
import Data.Ord
take 100 $ List.sortOn (Down . snd) cats
#+end_src

#+RESULTS:
: [("Data",2427),("Web",1990),("Network",1122),("Text",1029),("Development",861),("Control",818),("SYstem",785),("Language",769),("Math",724),("Graphics",629),("Database",539),("Unclassified",487),("Testing",435),("AWS",384),("Data Structures",325),("Game",296),("Parsing",257),("Concurrency",250),("Cloud",227),("Sound",216),("Codec",190),("Google",188),("Cryptography",175),("Distribution",153),("Compilers/Interpreters",147),("FFI",139),("Generics",135),("Algorithms",134),("Bioinformatics",129),("XML",116),("Foreign",114),("JSON",114),("Utils",113),("FRP",109),("Music",106),("Yesod",104),("Console",96),("Prelude",96),("Monads",92),("Natural Language Processing",92),("User Interfaces",92),("Finance",81),("GUI",81),("Numeric",81),("AI",79),("Conduit",76),("Compiler",72),("Numerical",72),("Machine Learning",69),("Hardware",68),("Statistics",66),("Utility",66),("Configuration",65),("Time",65),("Bindings",64),("Servant",64),("Distributed Computing",62),("Logging",62),("Streaming",61),("Algebra",58),("Library",58),("Lenses",56),("Pipes",56),("ACME",55),("Dependent Types",55),("Tools",53),("Theorem Provers",52),("CLI",50),("Debug",48),("Template Haskell",46),("Graphs",44),("Test",44),("Formal Methods",43),("Security",43),("Type System",42),("Game Engine",41),("Logic",41),("API",40),("Reactivity",39),("Filesystem",38),("Parallelism",38),("Records",38),("JavaScript",35),("Nix",35),("Physics",35),("Snap",35),("Application",34),("Compression",33),("Education",33),("Embedded",33),("Enumerator",33),("GHC",33),("Serialization",31),("Code Generation",30),("Crypto",30),("PostgreSQL",30),("Data Mining",28),("Other",28),("Parser",28),("Accelerate",27)]

RESULTS:
#+begin_example
[
    ( "Data"
    , 2427
    )
,
    ( "Web"
    , 1990
    )
,
    ( "Network"
    , 1122
    )
,
    ( "Text"
    , 1029
    )
,
    ( "Development"
    , 861
    )
,
    ( "Control"
    , 818
    )
,
    ( "SYstem"
    , 785
    )
,
    ( "Language"
    , 769
    )
,
    ( "Math"
    , 724
    )
,
    ( "Graphics"
    , 629
    )
,
    ( "Database"
    , 539
    )
,
    ( "Unclassified"
    , 487
    )
,
    ( "Testing"
    , 435
    )
,
    ( "AWS"
    , 384
    )
,
    ( "Data Structures"
    , 325
    )
,
    ( "Game"
    , 296
    )
,
    ( "Parsing"
    , 257
    )
,
    ( "Concurrency"
    , 250
    )
,
    ( "Cloud"
    , 227
    )
,
    ( "Sound"
    , 216
    )
,
    ( "Codec"
    , 190
    )
,
    ( "Google"
    , 188
    )
,
    ( "Cryptography"
    , 175
    )
,
    ( "Distribution"
    , 153
    )
,
    ( "Compilers/Interpreters"
    , 147
    )
,
    ( "FFI"
    , 139
    )
,
    ( "Generics"
    , 135
    )
,
    ( "Algorithms"
    , 134
    )
,
    ( "Bioinformatics"
    , 129
    )
,
    ( "XML"
    , 116
    )
,
    ( "Foreign"
    , 114
    )
,
    ( "JSON"
    , 114
    )
,
    ( "Utils"
    , 113
    )
,
    ( "FRP"
    , 109
    )
,
    ( "Music"
    , 106
    )
,
    ( "Yesod"
    , 104
    )
,
    ( "Console"
    , 96
    )
,
    ( "Prelude"
    , 96
    )
,
    ( "Monads"
    , 92
    )
,
    ( "Natural Language Processing"
    , 92
    )
,
    ( "User Interfaces"
    , 92
    )
,
    ( "Finance"
    , 81
    )
,
    ( "GUI"
    , 81
    )
,
    ( "Numeric"
    , 81
    )
,
    ( "AI"
    , 79
    )
,
    ( "Conduit"
    , 76
    )
,
    ( "Compiler"
    , 72
    )
,
    ( "Numerical"
    , 72
    )
,
    ( "Machine Learning"
    , 69
    )
,
    ( "Hardware"
    , 68
    )
]
#+end_example

* manual over-writes

#+begin_src haskell :results output
cfg = defaultConfig {replaceCategory = True, replaceCopyright = True}
#+end_src

#+RESULTS:

#+begin_src haskell :results output
void $ mapM (\(fp,bs) -> BS.writeFile ("/Users/tonyday/haskell/cabal-fix/test/rendered/" <> fp) bs) (second (cabalFix cfg) <$> cs)
#+end_src

#+RESULTS:

* individual directory cabal

#+begin_src haskell :results output
fp = "/Users/tonyday/haskell/eulerproject/eulerproject.cabal"
cfg = defaultConfig
cabalFixFile fp cfg
#+end_src

#+RESULTS:

* cabal-fix.hs development

#+begin_src haskell :results output
d <- getCurrentDirectory
fp = takeBaseName d <> ".cabal"
bs <- getCabalFile fp
bs' = cabalFix defaultConfig bs
ansiWlEditExpr <$> patch bs bs'
#+end_src

#+RESULTS:
#+begin_example
Just BS.concat
  [
    +"        , Diff\n",
    +"        , filepath\n",
    +"        , markup-parse\n",
    -"        , markup-parse\n",
    -"        , Diff\n",
    -"        , tree-diff\n",
    -"        , filepath\n",
    +"        , tree-diff          >=0.3 && <0.4\n",
    -"        , markup-parse\n",
    +"        , cabal-fix\n",
    -"        , cabal-fix\n",
    +"        , markup-parse\n"]
#+end_example


#+begin_src haskell :results output
cabalFixFile fp cfg
#+end_src

#+RESULTS:
#+begin_example
Just BS.concat
  [
    +"        , Diff\n",
    +"        , filepath\n",
    +"        , markup-parse\n",
    -"        , markup-parse\n",
    -"        , Diff\n",
    -"        , tree-diff\n",
    -"        , filepath\n",
    +"        , tree-diff          >=0.3 && <0.4\n",
    -"        , markup-parse\n",
    +"        , cabal-fix\n",
    -"        , cabal-fix\n",
    +"        , markup-parse\n"]
#+end_example

  #+begin_src haskell :results output
import Data.TreeDiff
fp = "/Users/tonyday/haskell/perf/perf.cabal"
bs <- getCabalFile fp
  #+end_src

#+RESULTS:

#+begin_src haskell :results output
bs' = cabalFix defaultConfig bs
#+end_src

#+RESULTS:

#+begin_src haskell :results output
ansiWlEditExpr <$> patch bs bs'
#+end_src

#+RESULTS:
: Nothing

* Sorted fieldOrdering

#+begin_src haskell-ng :results output
zipWith (\o l -> (fst l, o)) [0..] (List.sortOn snd $ fieldOrdering defaultConfig)
#+end_src

#+RESULTS:
: [("cabal-version",0),("import",1),("main-is",2),("default-language",3),("name",4),("hs-source-dirs",5),("version",6),("build-depends",7),("exposed-modules",8),("license",9),("license-file",10),("other-modules",11),("copyright",12),("category",13),("author",14),("default-extensions",15),("ghc-options",16),("maintainer",17),("homepage",18),("bug-reports",19),("synopsis",20),("description",21),("build-type",22),("tested-with",23),("extra-doc-files",24),("source-repository",25),("type",26),("common",27),("location",28),("library",29),("executable",30),("test-suite",31)]
